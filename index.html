// ì˜¤ë¥˜ ìˆ˜ì •ëœ ëª¨ë°”ì¼ í„°ì¹˜ í™˜ê²½ ê°œì„  ì½”ë“œ
function setupMobileTouchEnhancements() {
    let longPressTimer = null;
    let isDragging = false;
    let selectedEmotion = null;
    
    // í„°ì¹˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë“¤ì„ í•¨ìˆ˜ë¡œ ë¯¸ë¦¬ ì •ì˜ (ì´ë²¤íŠ¸ ì œê±°ë¥¼ ìœ„í•´)
    const touchHandlers = new WeakMap();
    
    // í•„ìˆ˜ í•¨ìˆ˜ë“¤ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ê³  ì—†ìœ¼ë©´ ì •ì˜
    if (typeof getCurrentEmotionLocation !== 'function') {
        window.getCurrentEmotionLocation = function(emotion) {
            // appStateê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
            if (typeof appState === 'undefined' || !appState.quadrantEmotions) {
                console.warn('appState.quadrantEmotionsê°€ ì •ì˜ë˜ì§€ ì•ŠìŒ');
                return 'source';
            }
            
            for (const [quadrant, emotions] of Object.entries(appState.quadrantEmotions)) {
                if (emotions.find(e => {
                    // ì•ˆì „í•œ ë¹„êµë¥¼ ìœ„í•´ null/undefined ì²´í¬
                    if (!e || !emotion) return false;
                    
                    // ë‹¤ì–‘í•œ í˜•íƒœì˜ ì´ë¦„ ë¹„êµ
                    const eName = e.name?.ko || e.name || '';
                    const emotionName = emotion.name?.ko || emotion.name || '';
                    
                    return eName === emotionName;
                })) {
                    return quadrant;
                }
            }
            return 'source';
        };
    }
    
    if (typeof removeEmotionFromAllLocations !== 'function') {
        window.removeEmotionFromAllLocations = function(emotion) {
            if (typeof appState === 'undefined' || !appState.quadrantEmotions) {
                console.warn('appState.quadrantEmotionsê°€ ì •ì˜ë˜ì§€ ì•ŠìŒ');
                return;
            }
            
            Object.keys(appState.quadrantEmotions).forEach(key => {
                appState.quadrantEmotions[key] = appState.quadrantEmotions[key].filter(e => {
                    if (!e || !emotion) return true;
                    
                    const eName = e.name?.ko || e.name || '';
                    const emotionName = emotion.name?.ko || emotion.name || '';
                    
                    return eName !== emotionName;
                });
            });
        };
    }
    
    if (typeof moveEmotionToSource !== 'function') {
        window.moveEmotionToSource = function(emotion) {
            removeEmotionFromAllLocations(emotion);
            
            // renderStep í•¨ìˆ˜ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
            if (typeof renderStep === 'function') {
                renderStep();
            }
            if (typeof updateUI === 'function') {
                updateUI();
            }
            if (typeof saveToStorage === 'function') {
                saveToStorage();
            }
        };
    }
    
    if (typeof showToast !== 'function') {
        window.showToast = function(message) {
            // ê¸°ì¡´ í† ìŠ¤íŠ¸ ì œê±°
            document.querySelectorAll('.custom-toast').forEach(t => t.remove());
            
            const toast = document.createElement('div');
            toast.className = 'custom-toast fixed top-20 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm';
            toast.style.animation = 'fadeInRight 0.3s ease-out';
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'fadeOutRight 0.3s ease-out';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }, 2000);
        };
    }
    
    if (typeof playSound !== 'function') {
        window.playSound = function(soundType) {
            // ì‚¬ìš´ë“œ ì¬ìƒì´ ê°€ëŠ¥í•œ ê²½ìš°ì—ë§Œ ì‹¤í–‰
            if (typeof appState !== 'undefined' && appState.soundEnabled) {
                console.log(`Playing sound: ${soundType}`);
                // ì‹¤ì œ ì‚¬ìš´ë“œ ì¬ìƒ ë¡œì§ì€ ì›ë³¸ ì½”ë“œì˜ sounds ê°ì²´ë¥¼ ì°¸ì¡°í•´ì•¼ í•¨
            }
        };
    }
    
    // ê°ì •ì¹´ë“œì— í„°ì¹˜ ì´ë²¤íŠ¸ ì¶”ê°€
    function addTouchEvents() {
        const emotionChips = document.querySelectorAll('.emotion-chip');
        
        emotionChips.forEach(chip => {
            // ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
            const existingHandlers = touchHandlers.get(chip);
            if (existingHandlers) {
                chip.removeEventListener('touchstart', existingHandlers.start);
                chip.removeEventListener('touchend', existingHandlers.end);
                chip.removeEventListener('touchmove', existingHandlers.move);
            }
            
            // ìƒˆ í•¸ë“¤ëŸ¬ ìƒì„±
            const handlers = {
                start: (e) => handleTouchStart(e, chip),
                end: (e) => handleTouchEnd(e, chip),
                move: (e) => handleTouchMove(e, chip)
            };
            
            // í•¸ë“¤ëŸ¬ ì €ì¥
            touchHandlers.set(chip, handlers);
            
            // ì´ë²¤íŠ¸ ì¶”ê°€
            chip.addEventListener('touchstart', handlers.start, { passive: false });
            chip.addEventListener('touchend', handlers.end, { passive: false });
            chip.addEventListener('touchmove', handlers.move, { passive: false });
        });
    }

    function handleTouchStart(e, chip) {
        // í„°ì¹˜ ì´ë²¤íŠ¸ê°€ ìœ íš¨í•œì§€ í™•ì¸
        if (!e.touches || e.touches.length === 0) {
            console.warn('í„°ì¹˜ ì´ë²¤íŠ¸ì— touches ë°°ì—´ì´ ì—†ìŒ');
            return;
        }
        
        // ì´ì „ íƒ€ì´ë¨¸ ì •ë¦¬
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        
        // ê¸¸ê²Œ ëˆ„ë¥´ê¸° ê°ì§€ ì‹œì‘
        longPressTimer = setTimeout(() => {
            showMobileContextMenu(chip, e.touches[0]);
            
            // í–…í‹± í”¼ë“œë°± (ì§€ì›ë˜ëŠ” ë¸Œë¼ìš°ì €ì—ì„œë§Œ)
            try {
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            } catch (err) {
                console.log('Vibration not supported');
            }
            
            longPressTimer = null;
        }, 500);
        
        // ì„ íƒ íš¨ê³¼
        chip.classList.add('touch-pressed');
    }

    function handleTouchMove(e, chip) {
        // ì›€ì§ì„ì´ ê°ì§€ë˜ë©´ ê¸¸ê²Œ ëˆ„ë¥´ê¸° ì·¨ì†Œ
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }

    function handleTouchEnd(e, chip) {
        // íƒ€ì´ë¨¸ ì •ë¦¬
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
            
            // ì§§ì€ íƒ­ ì²˜ë¦¬
            if (!selectedEmotion) {
                selectEmotionForMove(chip);
            } else if (selectedEmotion === chip) {
                deselectEmotion();
            } else {
                // ë‹¤ë¥¸ ê°ì •ì¹´ë“œ íƒ­ = ìœ„ì¹˜ êµí™˜
                swapEmotions(selectedEmotion, chip);
            }
        }
        
        // ì„ íƒ íš¨ê³¼ ì œê±°
        chip.classList.remove('touch-pressed');
    }

    function selectEmotionForMove(chip) {
        try {
            // ì´ì „ ì„ íƒ í•´ì œ
            document.querySelectorAll('.selected-for-move').forEach(el => {
                el.classList.remove('selected-for-move');
            });
            
            selectedEmotion = chip;
            chip.classList.add('selected-for-move');
            
            // 4ë¶„ë©´ë“¤ì„ í•˜ì´ë¼ì´íŠ¸
            document.querySelectorAll('.quadrant').forEach(quadrant => {
                quadrant.classList.add('move-target');
                
                // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° í›„ ì¶”ê°€
                const newHandler = (e) => handleQuadrantTap(e);
                quadrant.removeEventListener('click', quadrant._quadrantTapHandler);
                quadrant._quadrantTapHandler = newHandler;
                quadrant.addEventListener('click', newHandler);
            });
            
            // ì†ŒìŠ¤ ì˜ì—­ë„ í™œì„±í™”
            const sourceArea = document.getElementById('emotionSource');
            if (sourceArea) {
                sourceArea.classList.add('move-target');
                
                const newHandler = (e) => handleSourceTap(e);
                sourceArea.removeEventListener('click', sourceArea._sourceTapHandler);
                sourceArea._sourceTapHandler = newHandler;
                sourceArea.addEventListener('click', newHandler);
            }
            
            showToast('ì´ë™í•  ìœ„ì¹˜ë¥¼ íƒ­í•˜ì„¸ìš” (ë‹¤ì‹œ íƒ­í•˜ë©´ ì·¨ì†Œ)');
            
            // ìë™ ì·¨ì†Œ (10ì´ˆ í›„)
            setTimeout(() => {
                if (selectedEmotion === chip) {
                    deselectEmotion();
                }
            }, 10000);
            
        } catch (error) {
            console.error('selectEmotionForMove ì˜¤ë¥˜:', error);
            deselectEmotion();
        }
    }

    function deselectEmotion() {
        try {
            if (selectedEmotion) {
                selectedEmotion.classList.remove('selected-for-move');
                selectedEmotion = null;
            }
            
            // ëª¨ë“  íƒ€ê²Ÿ ë¹„í™œì„±í™”
            document.querySelectorAll('.move-target').forEach(target => {
                target.classList.remove('move-target');
                
                // ì €ì¥ëœ í•¸ë“¤ëŸ¬ ì œê±°
                if (target._quadrantTapHandler) {
                    target.removeEventListener('click', target._quadrantTapHandler);
                    target._quadrantTapHandler = null;
                }
                if (target._sourceTapHandler) {
                    target.removeEventListener('click', target._sourceTapHandler);
                    target._sourceTapHandler = null;
                }
            });
        } catch (error) {
            console.error('deselectEmotion ì˜¤ë¥˜:', error);
        }
    }

    function handleQuadrantTap(e) {
        if (!selectedEmotion) return;
        
        try {
            e.stopPropagation();
            const quadrant = e.currentTarget.dataset.quadrant;
            const emotionData = selectedEmotion.dataset.emotion || 
                               selectedEmotion.closest('[data-emotion]')?.dataset.emotion;
            
            if (emotionData && quadrant) {
                const emotion = JSON.parse(emotionData);
                moveEmotionToQuadrant(emotion, quadrant);
                deselectEmotion();
            }
        } catch (error) {
            console.error('handleQuadrantTap ì˜¤ë¥˜:', error);
            deselectEmotion();
        }
    }

    function handleSourceTap(e) {
        if (!selectedEmotion) return;
        
        try {
            e.stopPropagation();
            const emotionData = selectedEmotion.dataset.emotion || 
                               selectedEmotion.closest('[data-emotion]')?.dataset.emotion;
            
            if (emotionData) {
                const emotion = JSON.parse(emotionData);
                moveEmotionToSource(emotion);
                deselectEmotion();
            }
        } catch (error) {
            console.error('handleSourceTap ì˜¤ë¥˜:', error);
            deselectEmotion();
        }
    }

    function swapEmotions(chip1, chip2) {
        try {
            const emotion1Data = chip1.dataset.emotion || chip1.closest('[data-emotion]')?.dataset.emotion;
            const emotion2Data = chip2.dataset.emotion || chip2.closest('[data-emotion]')?.dataset.emotion;
            
            if (!emotion1Data || !emotion2Data) {
                console.warn('ê°ì • ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                return;
            }
            
            const emotion1 = JSON.parse(emotion1Data);
            const emotion2 = JSON.parse(emotion2Data);
            
            const location1 = getCurrentEmotionLocation(emotion1);
            const location2 = getCurrentEmotionLocation(emotion2);
            
            // ë‘ ê°ì •ì˜ ìœ„ì¹˜ êµí™˜
            removeEmotionFromAllLocations(emotion1);
            removeEmotionFromAllLocations(emotion2);
            
            if (location1 !== 'source' && typeof appState !== 'undefined' && appState.quadrantEmotions) {
                appState.quadrantEmotions[location1].push(emotion2);
            }
            if (location2 !== 'source' && typeof appState !== 'undefined' && appState.quadrantEmotions) {
                appState.quadrantEmotions[location2].push(emotion1);
            }
            
            showToast('ê°ì •ì¹´ë“œ ìœ„ì¹˜ê°€ êµí™˜ë˜ì—ˆì–´ìš”!');
            playSound('success');
            
            // UI ì—…ë°ì´íŠ¸
            if (typeof renderStep === 'function') renderStep();
            if (typeof updateUI === 'function') updateUI();
            if (typeof saveToStorage === 'function') saveToStorage();
            
            deselectEmotion();
            
        } catch (error) {
            console.error('swapEmotions ì˜¤ë¥˜:', error);
            deselectEmotion();
        }
    }

    function showMobileContextMenu(chip, touch) {
        try {
            const emotionData = chip.dataset.emotion || chip.closest('[data-emotion]')?.dataset.emotion;
            if (!emotionData) {
                console.warn('ê°ì • ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                return;
            }
            
            const emotion = JSON.parse(emotionData);
            const menu = createMobileMenu(emotion);
            
            // ê¸°ì¡´ ë©”ë‰´ ì œê±°
            document.querySelectorAll('.mobile-context-menu, .mobile-menu-overlay').forEach(m => m.remove());
            
            // í™”ë©´ ì¤‘ì•™ì— ë©”ë‰´ í‘œì‹œ
            menu.style.position = 'fixed';
            menu.style.top = '50%';
            menu.style.left = '50%';
            menu.style.transform = 'translate(-50%, -50%)';
            menu.style.zIndex = '1000';
            
            document.body.appendChild(menu);
            
            // ë°°ê²½ ì˜¤ë²„ë ˆì´ ì¶”ê°€
            const overlay = document.createElement('div');
            overlay.className = 'mobile-menu-overlay fixed inset-0 bg-black bg-opacity-50';
            overlay.style.zIndex = '999';
            overlay.addEventListener('click', () => {
                menu.remove();
                overlay.remove();
            });
            
            document.body.appendChild(overlay);
            
        } catch (error) {
            console.error('showMobileContextMenu ì˜¤ë¥˜:', error);
        }
    }

    function createMobileMenu(emotion) {
        const menu = document.createElement('div');
        menu.className = 'mobile-context-menu fixed bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-6 max-w-sm w-full mx-4';
        
        // ì•ˆì „í•œ ì–¸ì–´ ì ‘ê·¼
        const language = (typeof appState !== 'undefined' && appState.language) ? appState.language : 'ko';
        const currentLocation = getCurrentEmotionLocation(emotion);
        
        // ì•ˆì „í•œ ê°ì • ì´ë¦„ ë° ì„¤ëª… ì ‘ê·¼
        const emotionName = emotion.name?.[language] || emotion.name || 'ì•Œ ìˆ˜ ì—†ëŠ” ê°ì •';
        const emotionDescription = emotion.description?.[language] || emotion.description || '';
        
        menu.innerHTML = `
            <div class="text-center mb-6">
                <div class="text-4xl mb-2">${emotion.emoji || 'ğŸ˜'}</div>
                <h3 class="text-lg font-bold text-gray-800 dark:text-gray-200">
                    ${emotionName}
                </h3>
                <p class="text-sm text-gray-600 dark:text-gray-400">
                    ${emotionDescription}
                </p>
            </div>
            
            <div class="space-y-3">
                ${currentLocation !== 'source' ? `
                    <button onclick="mobileMenuAction('source', '${encodeURIComponent(JSON.stringify(emotion))}')" 
                            class="w-full py-3 px-4 bg-blue-500 text-white rounded-xl flex items-center justify-center space-x-2 text-sm font-medium">
                        <span>ğŸ”„</span>
                        <span>ë¶„ë¥˜í•¨ìœ¼ë¡œ ë˜ëŒë¦¬ê¸°</span>
                    </button>
                ` : ''}
                
                <div class="text-xs text-gray-500 dark:text-gray-400 text-center">ë‹¤ë¥¸ ë¶„ë©´ìœ¼ë¡œ ì´ë™</div>
                
                <div class="grid grid-cols-2 gap-3" id="quadrant-buttons">
                    <!-- 4ë¶„ë©´ ë²„íŠ¼ë“¤ì´ ì—¬ê¸°ì— ì¶”ê°€ë©ë‹ˆë‹¤ -->
                </div>
                
                <button onclick="closeMobileMenu()" 
                        class="w-full py-3 px-4 bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-xl text-sm font-medium">
                    ì·¨ì†Œ
                </button>
            </div>
        `;
        
        // 4ë¶„ë©´ ë²„íŠ¼ ì•ˆì „í•˜ê²Œ ì¶”ê°€
        const quadrantButtons = menu.querySelector('#quadrant-buttons');
        if (typeof quadrantInfo !== 'undefined' && quadrantButtons) {
            Object.keys(quadrantInfo).forEach(quadrant => {
                if (currentLocation === quadrant) return;
                
                const info = quadrantInfo[quadrant];
                const titleParts = info.title[language].split(' ');
                
                const button = document.createElement('button');
                button.onclick = () => mobileMenuAction(quadrant, encodeURIComponent(JSON.stringify(emotion)));
                button.className = `py-3 px-2 ${info.color} border-2 border-gray-200 rounded-xl text-xs font-medium text-center`;
                button.innerHTML = `
                    <div class="text-lg mb-1">${titleParts[0] || ''}</div>
                    <div>${titleParts[1] || ''}</div>
                `;
                
                quadrantButtons.appendChild(button);
            });
        }
        
        return menu;
    }

    // ì´ˆê¸° ì„¤ì •
    addTouchEvents();
    
    // renderStep í›„ ì¬ì„¤ì • (ì•ˆì „í•œ ë°©ì‹)
    if (typeof window.renderStep === 'function') {
        const originalRenderStep = window.renderStep;
        window.renderStep = function() {
            try {
                originalRenderStep.apply(this, arguments);
                setTimeout(() => {
                    addTouchEvents();
                }, 100);
            } catch (error) {
                console.error('renderStep ì˜¤ë¥˜:', error);
                // ì›ë³¸ í•¨ìˆ˜ë¼ë„ ì‹¤í–‰
                originalRenderStep.apply(this, arguments);
            }
        };
    }
    
    // ì •ë¦¬ í•¨ìˆ˜
    window.cleanupMobileTouchEvents = function() {
        // ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        
        // ì„ íƒ ìƒíƒœ ì •ë¦¬
        deselectEmotion();
        
        // ëª¨ë“  ë©”ë‰´ ì œê±°
        document.querySelectorAll('.mobile-context-menu, .mobile-menu-overlay').forEach(el => el.remove());
    };
}

// ëª¨ë°”ì¼ ë©”ë‰´ ì•¡ì…˜ í•¨ìˆ˜ë“¤ (ì˜¤ë¥˜ ì²˜ë¦¬ ì¶”ê°€)
window.mobileMenuAction = function(target, emotionJson) {
    try {
        const emotion = JSON.parse(decodeURIComponent(emotionJson));
        
        if (target === 'source') {
            moveEmotionToSource(emotion);
        } else {
            moveEmotionToQuadrant(emotion, target);
        }
        
        closeMobileMenu();
    } catch (error) {
        console.error('mobileMenuAction ì˜¤ë¥˜:', error);
        closeMobileMenu();
    }
};

window.closeMobileMenu = function() {
    try {
        document.querySelectorAll('.mobile-context-menu, .mobile-menu-overlay').forEach(el => el.remove());
    } catch (error) {
        console.error('closeMobileMenu ì˜¤ë¥˜:', error);
    }
};

function moveEmotionToQuadrant(emotion, quadrant) {
    try {
        // ì•ˆì „ì„± ì²´í¬
        if (typeof appState === 'undefined' || !appState.quadrantEmotions) {
            console.error('appState.quadrantEmotionsê°€ ì •ì˜ë˜ì§€ ì•ŠìŒ');
            return;
        }
        
        if (!quadrantInfo || !quadrantInfo[quadrant]) {
            console.error('ìœ íš¨í•˜ì§€ ì•Šì€ quadrant:', quadrant);
            return;
        }
        
        // ëª¨ë“  ìœ„ì¹˜ì—ì„œ ì œê±°
        removeEmotionFromAllLocations(emotion);
        
        // ìƒˆ ìœ„ì¹˜ì— ì¶”ê°€
        appState.quadrantEmotions[quadrant].push(emotion);
        
        // ì•ˆì „í•œ ì–¸ì–´ ì ‘ê·¼
        const language = appState.language || 'ko';
        const quadrantName = quadrantInfo[quadrant].title[language];
        const emotionName = emotion.name?.[language] || emotion.name || 'ê°ì •';
        
        showToast(`"${emotionName}"ì´(ê°€) ${quadrantName}ë¡œ ì´ë™í–ˆì–´ìš”!`);
        
        // UI ì—…ë°ì´íŠ¸
        if (typeof renderStep === 'function') renderStep();
        if (typeof updateUI === 'function') updateUI();
        if (typeof saveToStorage === 'function') saveToStorage();
        
        playSound('success');
        
    } catch (error) {
        console.error('moveEmotionToQuadrant ì˜¤ë¥˜:', error);
    }
}

// CSS ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
if (!document.querySelector('#mobile-touch-styles')) {
    const mobileStyle = document.createElement('style');
    mobileStyle.id = 'mobile-touch-styles';
    mobileStyle.textContent = `
        @keyframes fadeInRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        @keyframes fadeOutRight {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(20px); }
        }
        
        .touch-pressed {
            transform: scale(0.95);
            opacity: 0.8;
            transition: all 0.1s ease;
        }
        
        .selected-for-move {
            border: 2px solid #3b82f6 !important;
            background: rgba(59, 130, 246, 0.1) !important;
            animation: pulse-select 1.5s infinite;
        }
        
        @keyframes pulse-select {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 8px rgba(59, 130, 246, 0); }
        }
        
        .move-target {
            border: 2px dashed #10b981 !important;
            background: rgba(16, 185, 129, 0.1) !important;
            cursor: pointer;
            animation: move-target-pulse 1s infinite;
        }
        
        @keyframes move-target-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .mobile-context-menu {
            animation: mobileMenuSlideUp 0.3s ease-out;
        }
        
        @keyframes mobileMenuSlideUp {
            from { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.9); 
            }
            to { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1); 
            }
        }
        
        /* í„°ì¹˜ ë””ë°”ì´ìŠ¤ì—ì„œ í˜¸ë²„ íš¨ê³¼ ë¹„í™œì„±í™” */
        @media (hover: none) {
            .emotion-chip:hover {
                transform: none;
            }
        }
        
        /* í„°ì¹˜ íƒ€ê²Ÿ í¬ê¸° í™•ë³´ */
        @media (max-width: 640px) {
            .emotion-chip {
                min-height: 44px;
                min-width: 44px;
                padding: 8px 12px;
                font-size: 14px;
            }
            
            .quadrant {
                min-height: 150px;
                padding: 16px;
            }
        }
    `;
    document.head.appendChild(mobileStyle);
}
