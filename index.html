<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê°ì • 4ë¶„ë©´ íƒìƒ‰ê¸° - ê°œì„ ë²„ì „</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
    <style>
        /* ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            min-height: 80vh;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        /* ê°ì • ì†ŒìŠ¤ ì˜ì—­ */
        .emotion-source {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        /* 4ë¶„ë©´ ê·¸ë¦¬ë“œ */
        .quadrant-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
            height: 100%;
        }

        .quadrant {
            border-radius: 15px;
            padding: 20px;
            min-height: 200px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .quadrant:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .quadrant.drag-over {
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 2px dashed rgba(255, 255, 255, 0.5);
        }

        .quadrant-header {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        }

        .quadrant-title {
            font-size: 18px;
            font-weight: bold;
            color: white;
            margin-bottom: 5px;
        }

        .quadrant-subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }

        /* 4ë¶„ë©´ ìƒ‰ìƒ */
        .q1 { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); }
        .q2 { background: linear-gradient(135deg, #4ecdc4, #6ee6dd); }
        .q3 { background: linear-gradient(135deg, #45b7d1, #6cc3d6); }
        .q4 { background: linear-gradient(135deg, #96ceb4, #a8d5ba); }

        /* ê°ì • ì¹´ë“œ */
        .emotion-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid transparent;
            border-radius: 25px;
            padding: 8px 15px;
            margin: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            user-select: none;
            min-height: 44px;
            min-width: 44px;
        }

        .emotion-chip:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 1);
        }

        .emotion-chip.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .emotion-chip.touch-pressed {
            transform: scale(0.95);
            opacity: 0.8;
        }

        .emotion-chip.selected-for-move {
            border: 2px solid #3b82f6 !important;
            background: rgba(59, 130, 246, 0.1) !important;
            animation: pulse-select 1.5s infinite;
        }

        @keyframes pulse-select {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 8px rgba(59, 130, 246, 0); }
        }

        .move-target {
            border: 2px dashed #10b981 !important;
            background: rgba(16, 185, 129, 0.1) !important;
            animation: move-target-pulse 1s infinite;
        }

        @keyframes move-target-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ ì´ë¯¸ì§€ */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: rotate(-2deg);
        }

        /* ëª¨ë°”ì¼ ë©”ë‰´ */
        .mobile-context-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            max-width: 90vw;
            width: 320px;
            animation: mobileMenuSlideUp 0.3s ease-out;
        }

        @keyframes mobileMenuSlideUp {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .mobile-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* í† ìŠ¤íŠ¸ ë©”ì‹œì§€ */
        .custom-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            font-size: 14px;
            font-weight: 500;
            max-width: 300px;
            animation: fadeInRight 0.3s ease-out;
            pointer-events: none;
        }

        @keyframes fadeInRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes fadeOutRight {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(20px); }
        }

        /* í—¤ë” */
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        /* ë°˜ì‘í˜• */
        @media (max-width: 640px) {
            .container {
                padding: 15px;
            }

            .quadrant {
                min-height: 150px;
                padding: 15px;
            }

            .quadrant-title {
                font-size: 16px;
            }

            .emotion-chip {
                font-size: 13px;
                padding: 6px 12px;
            }

            .header h1 {
                font-size: 2rem;
            }
        }

        /* ë“œë¡­ ì˜ì—­ í•˜ì´ë¼ì´íŠ¸ */
        .emotion-source.drag-over {
            background: rgba(255, 255, 255, 1);
            border: 2px dashed #3b82f6;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- í—¤ë” -->
        <div class="header">
            <h1>ğŸ­ ê°ì • 4ë¶„ë©´ íƒìƒ‰ê¸°</h1>
            <p>ê°ì •ì„ ë¶„ë¥˜í•˜ê³  ì´í•´í•´ë³´ì„¸ìš”</p>
        </div>

        <!-- ë©”ì¸ ê·¸ë¦¬ë“œ -->
        <div class="main-grid">
            <!-- ê°ì • ì†ŒìŠ¤ ì˜ì—­ -->
            <div class="emotion-source" id="emotionSource">
                <h2 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 15px; color: #374151;">
                    ğŸ¯ ê°ì • ì¹´ë“œí•¨
                </h2>
                <p style="color: #6b7280; margin-bottom: 20px; font-size: 14px;">
                    ì•„ë˜ ê°ì •ë“¤ì„ ì ì ˆí•œ ë¶„ë©´ìœ¼ë¡œ ë“œë˜ê·¸í•˜ê±°ë‚˜ í„°ì¹˜í•´ë³´ì„¸ìš”
                </p>
                <div class="emotion-container" id="sourceContainer">
                    <!-- ê°ì • ì¹´ë“œë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
                </div>
            </div>

            <!-- 4ë¶„ë©´ ê·¸ë¦¬ë“œ -->
            <div class="quadrant-grid">
                <div class="quadrant q1" data-quadrant="q1">
                    <div class="quadrant-header">
                        <div class="quadrant-title">ğŸ˜¤ ê³ ì—ë„ˆì§€ ë¶€ì •</div>
                        <div class="quadrant-subtitle">ë¶„ë…¸, ìŠ¤íŠ¸ë ˆìŠ¤, ê¸´ì¥</div>
                    </div>
                    <div class="emotion-container" id="q1-emotions"></div>
                </div>

                <div class="quadrant q2" data-quadrant="q2">
                    <div class="quadrant-header">
                        <div class="quadrant-title">ğŸ˜Š ê³ ì—ë„ˆì§€ ê¸ì •</div>
                        <div class="quadrant-subtitle">ê¸°ì¨, ì‹ ë‚¨, í™œë ¥</div>
                    </div>
                    <div class="emotion-container" id="q2-emotions"></div>
                </div>

                <div class="quadrant q3" data-quadrant="q3">
                    <div class="quadrant-header">
                        <div class="quadrant-title">ğŸ˜” ì €ì—ë„ˆì§€ ë¶€ì •</div>
                        <div class="quadrant-subtitle">ìŠ¬í””, ìš°ìš¸, ë¬´ê¸°ë ¥</div>
                    </div>
                    <div class="emotion-container" id="q3-emotions"></div>
                </div>

                <div class="quadrant q4" data-quadrant="q4">
                    <div class="quadrant-header">
                        <div class="quadrant-title">ğŸ˜Œ ì €ì—ë„ˆì§€ ê¸ì •</div>
                        <div class="quadrant-subtitle">í‰ì˜¨, ë§Œì¡±, ì•ˆì •</div>
                    </div>
                    <div class="emotion-container" id="q4-emotions"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ì•± ìƒíƒœ ê´€ë¦¬
        let appState = {
            language: 'ko',
            soundEnabled: true,
            quadrantEmotions: {
                q1: [], // ê³ ì—ë„ˆì§€ ë¶€ì •
                q2: [], // ê³ ì—ë„ˆì§€ ê¸ì •
                q3: [], // ì €ì—ë„ˆì§€ ë¶€ì •
                q4: []  // ì €ì—ë„ˆì§€ ê¸ì •
            }
        };

        // 4ë¶„ë©´ ì •ë³´
        const quadrantInfo = {
            q1: {
                title: { ko: 'ê³ ì—ë„ˆì§€ ë¶€ì •', en: 'High Energy Negative' },
                color: 'bg-red-400',
                description: { ko: 'ë¶„ë…¸, ìŠ¤íŠ¸ë ˆìŠ¤, ê¸´ì¥', en: 'Anger, Stress, Tension' }
            },
            q2: {
                title: { ko: 'ê³ ì—ë„ˆì§€ ê¸ì •', en: 'High Energy Positive' },
                color: 'bg-teal-400',
                description: { ko: 'ê¸°ì¨, ì‹ ë‚¨, í™œë ¥', en: 'Joy, Excitement, Energy' }
            },
            q3: {
                title: { ko: 'ì €ì—ë„ˆì§€ ë¶€ì •', en: 'Low Energy Negative' },
                color: 'bg-blue-400',
                description: { ko: 'ìŠ¬í””, ìš°ìš¸, ë¬´ê¸°ë ¥', en: 'Sadness, Depression, Lethargy' }
            },
            q4: {
                title: { ko: 'ì €ì—ë„ˆì§€ ê¸ì •', en: 'Low Energy Positive' },
                color: 'bg-green-400',
                description: { ko: 'í‰ì˜¨, ë§Œì¡±, ì•ˆì •', en: 'Calm, Satisfaction, Stability' }
            }
        };

        // ê°ì • ë°ì´í„°
        const emotions = [
            { name: { ko: 'í–‰ë³µ', en: 'Happy' }, emoji: 'ğŸ˜Š', description: { ko: 'ê¸°ì˜ê³  ì¦ê±°ìš´ ìƒíƒœ', en: 'Joyful and cheerful state' } },
            { name: { ko: 'ìŠ¬í””', en: 'Sad' }, emoji: 'ğŸ˜¢', description: { ko: 'ìš°ìš¸í•˜ê³  ë‚™ë‹´í•œ ê¸°ë¶„', en: 'Melancholy and dejected feeling' } },
            { name: { ko: 'ë¶„ë…¸', en: 'Angry' }, emoji: 'ğŸ˜ ', description: { ko: 'í™”ê°€ ë‚˜ê³  ê²©ë¶„í•œ ìƒíƒœ', en: 'Furious and irritated state' } },
            { name: { ko: 'í‰ì˜¨', en: 'Calm' }, emoji: 'ğŸ˜Œ', description: { ko: 'ë§ˆìŒì´ ê³ ìš”í•˜ê³  ì•ˆì •ëœ ìƒíƒœ', en: 'Peaceful and stable state' } },
            { name: { ko: 'ì‹ ë‚¨', en: 'Excited' }, emoji: 'ğŸ¤©', description: { ko: 'í¥ë¶„ë˜ê³  ë“¤ëœ¬ ê¸°ë¶„', en: 'Thrilled and enthusiastic feeling' } },
            { name: { ko: 'í”¼ê³¤', en: 'Tired' }, emoji: 'ğŸ˜´', description: { ko: 'ì§€ì¹˜ê³  ë¬´ê¸°ë ¥í•œ ìƒíƒœ', en: 'Exhausted and weary state' } },
            { name: { ko: 'ë¶ˆì•ˆ', en: 'Anxious' }, emoji: 'ğŸ˜°', description: { ko: 'ê±±ì •ë˜ê³  ì´ˆì¡°í•œ ë§ˆìŒ', en: 'Worried and restless mind' } },
            { name: { ko: 'ë§Œì¡±', en: 'Content' }, emoji: 'ğŸ˜Š', description: { ko: 'ì¶©ì¡±ë˜ê³  í¡ì¡±í•œ ê¸°ë¶„', en: 'Satisfied and fulfilled feeling' } },
            { name: { ko: 'ìŠ¤íŠ¸ë ˆìŠ¤', en: 'Stressed' }, emoji: 'ğŸ˜«', description: { ko: 'ê¸´ì¥ë˜ê³  ì••ë°•ê°ì„ ëŠë¼ëŠ” ìƒíƒœ', en: 'Tense and pressured state' } },
            { name: { ko: 'í¬ë§', en: 'Hopeful' }, emoji: 'ğŸŒŸ', description: { ko: 'ë¯¸ë˜ì— ëŒ€í•œ ê¸ì •ì  ê¸°ëŒ€', en: 'Positive expectation for future' } },
            { name: { ko: 'ì™¸ë¡œì›€', en: 'Lonely' }, emoji: 'ğŸ˜”', description: { ko: 'í˜¼ìë¼ëŠ” ëŠë‚Œì˜ ì“¸ì“¸í•¨', en: 'Solitary and melancholic feeling' } },
            { name: { ko: 'ê°ì‚¬', en: 'Grateful' }, emoji: 'ğŸ™', description: { ko: 'ê³ ë§ˆì›€ì„ ëŠë¼ëŠ” ë§ˆìŒ', en: 'Thankful and appreciative heart' } }
        ];

        // ë””ë°”ì´ìŠ¤ íƒ€ì… ê°ì§€
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í‘œì‹œ
        function showToast(message) {
            // ê¸°ì¡´ í† ìŠ¤íŠ¸ ì œê±°
            document.querySelectorAll('.custom-toast').forEach(t => t.remove());

            const toast = document.createElement('div');
            toast.className = 'custom-toast';
            toast.textContent = message;

            document.body.appendChild(toast);

            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'fadeOutRight 0.3s ease-out';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, 2000);
        }

        // ê°ì • ì¹´ë“œ ìƒì„±
        function createEmotionChip(emotion) {
            const chip = document.createElement('div');
            chip.className = 'emotion-chip';
            chip.dataset.emotion = JSON.stringify(emotion);
            chip.draggable = true; // ë“œë˜ê·¸ ê°€ëŠ¥ ì„¤ì •

            const emoji = document.createElement('span');
            emoji.textContent = emotion.emoji;

            const name = document.createElement('span');
            name.textContent = emotion.name[appState.language];

            chip.appendChild(emoji);
            chip.appendChild(name);

            // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì¶”ê°€
            addDragEvents(chip);

            return chip;
        }

        // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì¶”ê°€
        function addDragEvents(chip) {
            // ë°ìŠ¤í¬í†± ë“œë˜ê·¸ ì´ë²¤íŠ¸
            chip.addEventListener('dragstart', handleDragStart);
            chip.addEventListener('dragend', handleDragEnd);

            // í„°ì¹˜ ì´ë²¤íŠ¸ëŠ” ë³„ë„ë¡œ ì²˜ë¦¬
            if (isTouchDevice) {
                addTouchEventsToChip(chip);
            }
        }

        // ë“œë˜ê·¸ ì‹œì‘
        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        // ë“œë˜ê·¸ ì¢…ë£Œ
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');

            // ëª¨ë“  ë“œë˜ê·¸ ì˜¤ë²„ íš¨ê³¼ ì œê±°
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        }

        // ë“œë¡­ ì˜ì—­ ì„¤ì •
        function setupDropZones() {
            // 4ë¶„ë©´ ë“œë¡­ ì˜ì—­
            document.querySelectorAll('.quadrant').forEach(quadrant => {
                quadrant.addEventListener('dragover', handleDragOver);
                quadrant.addEventListener('drop', handleDrop);
                quadrant.addEventListener('dragenter', handleDragEnter);
                quadrant.addEventListener('dragleave', handleDragLeave);
            });

            // ì†ŒìŠ¤ ì˜ì—­ ë“œë¡­ ì„¤ì •
            const sourceArea = document.getElementById('emotionSource');
            sourceArea.addEventListener('dragover', handleDragOver);
            sourceArea.addEventListener('drop', handleDropToSource);
            sourceArea.addEventListener('dragenter', handleDragEnter);
            sourceArea.addEventListener('dragleave', handleDragLeave);
        }

        // ë“œë˜ê·¸ ì˜¤ë²„
        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        // ë“œë˜ê·¸ ì—”í„°
        function handleDragEnter(e) {
            this.classList.add('drag-over');
        }

        // ë“œë˜ê·¸ ë¦¬ë¸Œ
        function handleDragLeave(e) {
            if (e.target === this) {
                this.classList.remove('drag-over');
            }
        }

        // ë“œë¡­ ì²˜ë¦¬
        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();

            this.classList.remove('drag-over');

            if (draggedElement) {
                const emotionData = draggedElement.dataset.emotion;
                if (emotionData) {
                    const emotion = JSON.parse(emotionData);
                    const targetQuadrant = this.dataset.quadrant;

                    if (targetQuadrant) {
                        moveEmotionToQuadrant(emotion, targetQuadrant);
                    }
                }
            }

            return false;
        }

        // ì†ŒìŠ¤ë¡œ ë“œë¡­
        function handleDropToSource(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();

            this.classList.remove('drag-over');

            if (draggedElement) {
                const emotionData = draggedElement.dataset.emotion;
                if (emotionData) {
                    const emotion = JSON.parse(emotionData);
                    moveEmotionToSource(emotion);
                }
            }

            return false;
        }

        // UI ë Œë”ë§
        function renderStep() {
            // ì†ŒìŠ¤ ì˜ì—­ ë Œë”ë§
            const sourceContainer = document.getElementById('sourceContainer');
            sourceContainer.innerHTML = '';

            emotions.forEach(emotion => {
                if (!isEmotionInQuadrant(emotion)) {
                    sourceContainer.appendChild(createEmotionChip(emotion));
                }
            });

            // ê° ë¶„ë©´ ë Œë”ë§
            Object.keys(appState.quadrantEmotions).forEach(quadrant => {
                const container = document.getElementById(`${quadrant}-emotions`);
                container.innerHTML = '';

                appState.quadrantEmotions[quadrant].forEach(emotion => {
                    container.appendChild(createEmotionChip(emotion));
                });
            });

            // í„°ì¹˜ ì´ë²¤íŠ¸ ì¬ì„¤ì •
            if (isTouchDevice) {
                setTimeout(() => {
                    addTouchEvents();
                }, 50);
            }
        }

        // ê°ì •ì´ ì–´ëŠ ë¶„ë©´ì— ìˆëŠ”ì§€ í™•ì¸
        function isEmotionInQuadrant(emotion) {
            for (const [quadrant, emotions] of Object.entries(appState.quadrantEmotions)) {
                if (emotions.find(e => e.name.ko === emotion.name.ko)) {
                    return true;
                }
            }
            return false;
        }

        // í˜„ì¬ ê°ì • ìœ„ì¹˜ ì°¾ê¸°
        function getCurrentEmotionLocation(emotion) {
            for (const [quadrant, emotions] of Object.entries(appState.quadrantEmotions)) {
                if (emotions.find(e => e.name.ko === emotion.name.ko)) {
                    return quadrant;
                }
            }
            return 'source';
        }

        // ëª¨ë“  ìœ„ì¹˜ì—ì„œ ê°ì • ì œê±°
        function removeEmotionFromAllLocations(emotion) {
            Object.keys(appState.quadrantEmotions).forEach(key => {
                appState.quadrantEmotions[key] = appState.quadrantEmotions[key].filter(e =>
                    e.name.ko !== emotion.name.ko
                );
            });
        }

        // ê°ì •ì„ ì†ŒìŠ¤ë¡œ ì´ë™
        function moveEmotionToSource(emotion) {
            removeEmotionFromAllLocations(emotion);
            showToast(`"${emotion.name.ko}"ê°€ ì¹´ë“œí•¨ìœ¼ë¡œ ëŒì•„ê°”ì–´ìš”!`);
            renderStep();
            saveToStorage();
        }

        // ê°ì •ì„ ë¶„ë©´ìœ¼ë¡œ ì´ë™
        function moveEmotionToQuadrant(emotion, quadrant) {
            removeEmotionFromAllLocations(emotion);
            appState.quadrantEmotions[quadrant].push(emotion);

            const quadrantName = quadrantInfo[quadrant].title[appState.language];
            showToast(`"${emotion.name.ko}"ì´(ê°€) ${quadrantName}ë¡œ ì´ë™í–ˆì–´ìš”!`);

            renderStep();
            saveToStorage();
        }

        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
        function saveToStorage() {
            try {
                localStorage.setItem('emotionQuadrantState', JSON.stringify(appState));
            } catch (error) {
                console.error('ì €ì¥ ì‹¤íŒ¨:', error);
            }
        }

        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¡œë“œ
        function loadFromStorage() {
            try {
                const saved = localStorage.getItem('emotionQuadrantState');
                if (saved) {
                    const loadedState = JSON.parse(saved);
                    appState = { ...appState, ...loadedState };
                }
            } catch (error) {
                console.error('ë¡œë“œ ì‹¤íŒ¨:', error);
            }
        }

        // í„°ì¹˜ ìƒíƒœ ê´€ë¦¬
        let touchState = {
            selectedEmotion: null,
            isInitialized: false,
            handlers: new WeakMap()
        };

        // í„°ì¹˜ ì´ë²¤íŠ¸ ì¶”ê°€ (ê°œë³„ ì¹©)
        function addTouchEventsToChip(chip) {
            let chipState = {
                longPressTimer: null,
                touchStartTime: 0,
                touchStartPos: null
            };

            chip.addEventListener('touchstart', (e) => {
                e.preventDefault();

                chipState.touchStartTime = Date.now();
                chipState.touchStartPos = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };

                // ê¸¸ê²Œ ëˆ„ë¥´ê¸° ê°ì§€
                chipState.longPressTimer = setTimeout(() => {
                    handleLongPress(chip);
                    chipState.longPressTimer = null;
                }, 500);

                chip.classList.add('touch-pressed');
            }, { passive: false });

            chip.addEventListener('touchmove', (e) => {
                if (chipState.longPressTimer && chipState.touchStartPos) {
                    const currentPos = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };

                    const distance = Math.sqrt(
                        Math.pow(currentPos.x - chipState.touchStartPos.x, 2) +
                        Math.pow(currentPos.y - chipState.touchStartPos.y, 2)
                    );

                    if (distance > 10) {
                        clearTimeout(chipState.longPressTimer);
                        chipState.longPressTimer = null;
                    }
                }
            }, { passive: false });

            chip.addEventListener('touchend', (e) => {
                if (chipState.longPressTimer) {
                    clearTimeout(chipState.longPressTimer);
                    chipState.longPressTimer = null;

                    const touchDuration = Date.now() - chipState.touchStartTime;
                    if (touchDuration < 500) {
                        handleShortTap(chip);
                    }
                }

                chip.classList.remove('touch-pressed');
            }, { passive: false });
        }

        // í„°ì¹˜ ì´ë²¤íŠ¸ ì¶”ê°€
        function addTouchEvents() {
            const emotionChips = document.querySelectorAll('.emotion-chip');

            emotionChips.forEach(chip => {
                // ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
                const existingHandlers = touchState.handlers.get(chip);
                if (existingHandlers) {
                    chip.removeEventListener('touchstart', existingHandlers.start);
                    chip.removeEventListener('touchend', existingHandlers.end);
                    chip.removeEventListener('touchmove', existingHandlers.move);
                }

                // ìƒˆ í•¸ë“¤ëŸ¬ ìƒì„±
                const handlers = createTouchHandlers(chip);
                touchState.handlers.set(chip, handlers);

                // ì´ë²¤íŠ¸ ì¶”ê°€
                chip.addEventListener('touchstart', handlers.start, { passive: false });
                chip.addEventListener('touchend', handlers.end, { passive: false });
                chip.addEventListener('touchmove', handlers.move, { passive: false });
            });
        }

        // í„°ì¹˜ í•¸ë“¤ëŸ¬ ìƒì„±
        function createTouchHandlers(chip) {
            let chipState = {
                longPressTimer: null,
                touchStartTime: 0,
                touchStartPos: null
            };

            return {
                start: function(e) {
                    e.preventDefault();

                    if (chipState.longPressTimer) {
                        clearTimeout(chipState.longPressTimer);
                    }

                    chipState.touchStartTime = Date.now();
                    chipState.touchStartPos = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };

                    // ê¸¸ê²Œ ëˆ„ë¥´ê¸° ê°ì§€
                    chipState.longPressTimer = setTimeout(() => {
                        if (chip.isConnected) {
                            handleLongPress(chip);
                        }
                        chipState.longPressTimer = null;
                    }, 500);

                    chip.classList.add('touch-pressed');
                },

                move: function(e) {
                    if (chipState.longPressTimer && chipState.touchStartPos) {
                        const currentPos = {
                            x: e.touches[0]?.clientX || 0,
                            y: e.touches[0]?.clientY || 0
                        };

                        const distance = Math.sqrt(
                            Math.pow(currentPos.x - chipState.touchStartPos.x, 2) +
                            Math.pow(currentPos.y - chipState.touchStartPos.y, 2)
                        );

                        if (distance > 10) {
                            clearTimeout(chipState.longPressTimer);
                            chipState.longPressTimer = null;
                        }
                    }
                },

                end: function(e) {
                    if (chipState.longPressTimer) {
                        clearTimeout(chipState.longPressTimer);
                        chipState.longPressTimer = null;

                        const touchDuration = Date.now() - chipState.touchStartTime;
                        if (touchDuration < 500 && chip.isConnected) {
                            handleShortTap(chip);
                        }
                    }

                    chip.classList.remove('touch-pressed');
                    chipState.touchStartTime = 0;
                    chipState.touchStartPos = null;
                }
            };
        }

        // ì§§ì€ íƒ­ ì²˜ë¦¬
        function handleShortTap(chip) {
            if (!touchState.selectedEmotion) {
                selectEmotionForMove(chip);
            } else if (touchState.selectedEmotion === chip) {
                deselectEmotion();
            } else {
                swapEmotions(touchState.selectedEmotion, chip);
            }
        }

        // ê¸¸ê²Œ ëˆ„ë¥´ê¸° ì²˜ë¦¬
        function handleLongPress(chip) {
            showMobileContextMenu(chip);

            // í–…í‹± í”¼ë“œë°±
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        }

        // ê°ì • ì„ íƒ
        function selectEmotionForMove(chip) {
            deselectEmotion();

            touchState.selectedEmotion = chip;
            chip.classList.add('selected-for-move');

            activateTargetAreas();
            showToast('ì´ë™í•  ìœ„ì¹˜ë¥¼ íƒ­í•˜ì„¸ìš” (ë‹¤ì‹œ íƒ­í•˜ë©´ ì·¨ì†Œ)');

            setTimeout(() => {
                if (touchState.selectedEmotion === chip) {
                    deselectEmotion();
                }
            }, 10000);
        }

        // íƒ€ê²Ÿ ì˜ì—­ í™œì„±í™”
        function activateTargetAreas() {
            document.querySelectorAll('.quadrant').forEach(quadrant => {
                quadrant.classList.add('move-target');

                if (!quadrant._touchMoveHandler) {
                    quadrant._touchMoveHandler = (e) => handleQuadrantTap(e);
                    quadrant.addEventListener('click', quadrant._touchMoveHandler);
                }
            });

            const sourceArea = document.getElementById('emotionSource');
            if (sourceArea) {
                sourceArea.classList.add('move-target');

                if (!sourceArea._touchMoveHandler) {
                    sourceArea._touchMoveHandler = (e) => handleSourceTap(e);
                    sourceArea.addEventListener('click', sourceArea._touchMoveHandler);
                }
            }
        }

        // ì„ íƒ í•´ì œ
        function deselectEmotion() {
            if (touchState.selectedEmotion) {
                touchState.selectedEmotion.classList.remove('selected-for-move');
                touchState.selectedEmotion = null;
            }

            document.querySelectorAll('.move-target').forEach(target => {
                target.classList.remove('move-target');

                if (target._touchMoveHandler) {
                    target.removeEventListener('click', target._touchMoveHandler);
                    target._touchMoveHandler = null;
                }
            });
        }

        // ë¶„ë©´ íƒ­ ì²˜ë¦¬
        function handleQuadrantTap(e) {
            if (!touchState.selectedEmotion) return;

            e.stopPropagation();
            const quadrant = e.currentTarget.dataset.quadrant;
            const emotionData = touchState.selectedEmotion.dataset.emotion;

            if (emotionData && quadrant) {
                const emotion = JSON.parse(emotionData);
                moveEmotionToQuadrant(emotion, quadrant);
                deselectEmotion();
            }
        }

        // ì†ŒìŠ¤ íƒ­ ì²˜ë¦¬
        function handleSourceTap(e) {
            if (!touchState.selectedEmotion) return;

            e.stopPropagation();
            const emotionData = touchState.selectedEmotion.dataset.emotion;

            if (emotionData) {
                const emotion = JSON.parse(emotionData);
                moveEmotionToSource(emotion);
                deselectEmotion();
            }
        }

        // ê°ì • ìœ„ì¹˜ êµí™˜
        function swapEmotions(chip1, chip2) {
            try {
                const emotion1Data = chip1.dataset.emotion;
                const emotion2Data = chip2.dataset.emotion;

                if (!emotion1Data || !emotion2Data) return;

                const emotion1 = JSON.parse(emotion1Data);
                const emotion2 = JSON.parse(emotion2Data);

                const location1 = getCurrentEmotionLocation(emotion1);
                const location2 = getCurrentEmotionLocation(emotion2);

                removeEmotionFromAllLocations(emotion1);
                removeEmotionFromAllLocations(emotion2);

                if (location1 !== 'source') {
                    appState.quadrantEmotions[location1].push(emotion2);
                }
                if (location2 !== 'source') {
                    appState.quadrantEmotions[location2].push(emotion1);
                }

                showToast('ê°ì •ì¹´ë“œ ìœ„ì¹˜ê°€ êµí™˜ë˜ì—ˆì–´ìš”!');
                renderStep();
                saveToStorage();
                deselectEmotion();

            } catch (error) {
                console.error('êµí™˜ ì˜¤ë¥˜:', error);
                deselectEmotion();
            }
        }

        // ëª¨ë°”ì¼ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
        function showMobileContextMenu(chip) {
            try {
                const emotionData = chip.dataset.emotion;
                if (!emotionData) return;

                const emotion = JSON.parse(emotionData);
                const menu = createMobileMenu(emotion);

                document.querySelectorAll('.mobile-context-menu, .mobile-menu-overlay').forEach(m => m.remove());

                document.body.appendChild(menu);

                const overlay = createOverlay(() => {
                    menu.remove();
                    overlay.remove();
                });

                document.body.appendChild(overlay);

            } catch (error) {
                console.error('ë©”ë‰´ í‘œì‹œ ì˜¤ë¥˜:', error);
            }
        }

        // ëª¨ë°”ì¼ ë©”ë‰´ ìƒì„±
        function createMobileMenu(emotion) {
            const menu = document.createElement('div');
            menu.className = 'mobile-context-menu';

            const currentLocation = getCurrentEmotionLocation(emotion);
            const emotionName = emotion.name[appState.language];
            const emotionDescription = emotion.description[appState.language];

            menu.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">${emotion.emoji}</div>
                    <h3 style="font-size: 1.25rem; font-weight: bold; color: #374151; margin-bottom: 5px;">
                        ${emotionName}
                    </h3>
                    <p style="font-size: 0.875rem; color: #6b7280;">
                        ${emotionDescription}
                    </p>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    ${currentLocation !== 'source' ? `
                        <button class="move-to-source-btn" style="width: 100%; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 12px; font-size: 0.875rem; font-weight: 500; cursor: pointer;">
                            ğŸ”„ ì¹´ë“œí•¨ìœ¼ë¡œ ë˜ëŒë¦¬ê¸°
                        </button>
                    ` : ''}
                    
                    <div style="font-size: 0.75rem; color: #6b7280; text-align: center; margin: 8px 0;">ë‹¤ë¥¸ ë¶„ë©´ìœ¼ë¡œ ì´ë™</div>
                    
                    <div class="quadrant-buttons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <!-- 4ë¶„ë©´ ë²„íŠ¼ë“¤ì´ ì—¬ê¸°ì— ì¶”ê°€ë©ë‹ˆë‹¤ -->
                    </div>
                    
                    <button class="close-menu-btn" style="width: 100%; padding: 12px; background: #e5e7eb; color: #374151; border: none; border-radius: 12px; font-size: 0.875rem; font-weight: 500; cursor: pointer;">
                        ì·¨ì†Œ
                    </button>
                </div>
            `;

            setupMenuEventListeners(menu, emotion, currentLocation);

            return menu;
        }

        // ë©”ë‰´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupMenuEventListeners(menu, emotion, currentLocation) {
            // ë¶„ë¥˜í•¨ìœ¼ë¡œ ë˜ëŒë¦¬ê¸° ë²„íŠ¼
            const sourceBtn = menu.querySelector('.move-to-source-btn');
            if (sourceBtn) {
                sourceBtn.addEventListener('click', () => {
                    moveEmotionToSource(emotion);
                    closeAllMenus();
                });
            }

            // 4ë¶„ë©´ ë²„íŠ¼ë“¤ ì¶”ê°€
            const quadrantContainer = menu.querySelector('.quadrant-buttons');
            Object.keys(quadrantInfo).forEach(quadrant => {
                if (currentLocation === quadrant) return;

                const info = quadrantInfo[quadrant];
                const titleParts = info.title[appState.language].split(' ');

                const button = document.createElement('button');
                button.style.cssText = `
                    padding: 12px 8px;
                    border: 2px solid #e5e7eb;
                    border-radius: 12px;
                    font-size: 0.75rem;
                    font-weight: 500;
                    text-align: center;
                    cursor: pointer;
                    background: ${getQuadrantColor(quadrant)};
                    color: white;
                `;
                button.innerHTML = `
                    <div style="font-size: 1rem; margin-bottom: 4px;">${titleParts[0] || ''}</div>
                    <div>${titleParts[1] || ''}</div>
                `;

                button.addEventListener('click', () => {
                    moveEmotionToQuadrant(emotion, quadrant);
                    closeAllMenus();
                });

                quadrantContainer.appendChild(button);
            });

            // ì·¨ì†Œ ë²„íŠ¼
            const closeBtn = menu.querySelector('.close-menu-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeAllMenus);
            }
        }

        // ë¶„ë©´ ìƒ‰ìƒ ë°˜í™˜
        function getQuadrantColor(quadrant) {
            const colors = {
                q1: '#ff6b6b',
                q2: '#4ecdc4',
                q3: '#45b7d1',
                q4: '#96ceb4'
            };
            return colors[quadrant] || '#6b7280';
        }

        // ì˜¤ë²„ë ˆì´ ìƒì„±
        function createOverlay(onClick) {
            const overlay = document.createElement('div');
            overlay.className = 'mobile-menu-overlay';
            overlay.addEventListener('click', onClick);
            return overlay;
        }

        // ëª¨ë“  ë©”ë‰´ ë‹«ê¸°
        function closeAllMenus() {
            document.querySelectorAll('.mobile-context-menu, .mobile-menu-overlay').forEach(el => el.remove());
        }

        // ì´ˆê¸°í™”
        function init() {
            loadFromStorage();
            renderStep();
            setupDropZones();
            touchState.isInitialized = true;

            console.log('ê°ì • 4ë¶„ë©´ íƒìƒ‰ê¸° ì´ˆê¸°í™” ì™„ë£Œ!');
            console.log('Touch device:', isTouchDevice);
        }

        // ì•± ì‹œì‘
        window.addEventListener('DOMContentLoaded', init);

        // ì „ì—­ í•¨ìˆ˜ ë“±ë¡ (ë””ë²„ê¹…ìš©)
        window.appState = appState;
        window.quadrantInfo = quadrantInfo;
        window.getCurrentEmotionLocation = getCurrentEmotionLocation;
        window.removeEmotionFromAllLocations = removeEmotionFromAllLocations;
        window.moveEmotionToSource = moveEmotionToSource;
        window.showToast = showToast;
        window.renderStep = renderStep;
        window.saveToStorage = saveToStorage;
        
        // ë°ì´í„° ì´ˆê¸°í™” í•¨ìˆ˜ (í•„ìš”ì‹œ ì½˜ì†”ì—ì„œ ì‚¬ìš©)
        window.resetAllData = function() {
            if (confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                localStorage.clear();
                location.reload();
            }
        };
    </script>
</body>
</html>
